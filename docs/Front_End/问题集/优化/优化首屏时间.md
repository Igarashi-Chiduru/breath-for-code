---
title: 优化首屏时间
order: 2
group:
  title: 优化合集
  order: 52
---

优化首屏时间：https://juejin.im/entry/5bacd491e51d450e4f38d30a
结合本节笔记 6.3 浏览器缓存策略部分开始

一、优化缓存机制：
通过配置 Etag 来控制浏览器的缓存：
Nginx 中通过 nginxPath/conf/nginx.conf 下的
etag on ——> 开启 etag 验证
expires 7d ——> 设置缓存过期时间 为 7 天

        打开我们的网站，在 chrome devtools 的 network 面板中观察我们的请求资源，如果在响应头部看见 Etag 和 Expires 字段，
        就说明我们的缓存配置成功了。Cache-Control: 中可以看到缓存控制。

        注意：
            配置缓存时一定要切记，浏览器在处理用户请求时，如果命中强缓存，浏览器会直接拉取本地缓存，不会与服务器发生任何通信。
            在服务器端更新了文件，并不会被浏览器得知，就无法替换失效的缓存。所以我们在构建阶段，需要为我们的静态资源添加 md5
            hash 后缀，避免资源更新而引起的 前 后端文件无法同步的问题。

    非常危险的模式结合：
        Cache-Control: max-age=600, must-revalidate
        若想设置no-cache，相当于max-age = 0，must-revalidate 时效性没有那么强（没必要不缓存一直请求新页面）。但又不想做时间较长的
        强制缓存（至于为啥，我没想明白）而配置了 max-age = 600，must-revalidate 这样折中的设置。

        表面上看这很美好：资源可以缓存 10 分钟，10 分钟内读取缓存，10 分钟后和服务器进行一次验证，集两种模式之大成，但实际线上暗存风险。

        因为上面提过，浏览器的缓存有自动清理机制，开发者并不能控制。因此风险如下：

        1.可能有的js文件被清除了，而html和css在浏览器的缓存中，此时会向服务器请求新的js，配合缓存中老的html有可能报错（没懂的是这
            次请求按理来说会校验才对，有html的变化是能够发现的啊）
        2.A、B页面有相同的css文件，按照A -> B 的顺序访问，导致B页面的css用了A页面的缓存时间早于B页面后加载的js文件。因此以后访问
            B页面时css的缓存可能已经失效，但js没有失效。

        没懂的是这和这种模式的关系看起来貌似不大啊。长时间强制缓存感觉也会出现以上问题。

二、资源打包压缩：
以上所作的浏览器缓存工作，只有在用户第二次访问页面才能起到效果。若想首次打开页面就实现优良的性能，必须对资源进行优化。
我们常将网络性能优化措施归结为三大方面：减少请求数、减小请求资源体积、提升网络传输速率。

    结合前端工程化思想，我们在对上线文件进行自动化打包编译时，通常都需要打包工具的协助，这里推荐 webpack。
    我通常都使用 Gulp 和 Grunt 来编译 node，Parcel 太新，而且 webpack 也一直在自身的特性上向 Parcel 靠拢。

    1.在对 webpack 进行上线配置时，我们要特别注意以下几点：
        <1>.JS 压缩:
            optimization: {
                minimizer: [
                    new UglifyJsPlugin({
                        cache: true,
                        parallel: true,
                        sourceMap: true // set to true if you want JS source maps
                    }),
                    ...Plugins
                ]
            }
        <2>.HTML 压缩：
            new HtmlWebpackPlugin({
                template: __dirname + '/views/index.html', // new 一个这个插件的实例，并传入相关的参数
                filename: '../index.html',
                minify: {
                    removeComments: true,
                    collapseWhitespace: true,
                    removeRedundantAttributes: true,
                    useShortDoctype: true,
                    removeEmptyAttributes: true,
                    removeStyleLinkTypeAttributes: true,
                    keepClosingSlash: true,
                    minifyJS: true,
                    minifyCSS: true,
                    minifyURLs: true,
                },
                chunksSortMode: 'dependency'
            })

        我们在使用html-webpack-plugin 自动化注入 JS、CSS 打包 HTML 文件时，很少会为其添加配置项，这里给出样例，直接复制就行。
        在 Webpack5 中，html-webpack-plugin的功能会像common-chunk-plugin那样，被集成到 webpack 内部，这样我们就不需要再
        install 额外的插件了。

        下文具体详情不记笔记了，直接看链接吧。详细记录知识点。

        ...

        将 webpack 开发环境修改为生产环境：
            devtool: 'false'    //在使用 webpack 打包项目时，它常常会引入一些调试代码，以作相关调试，我们在上线时不需要这部分内容

        在服务器上开启 Gzip 传输压缩:
            gzip on;
            gzip_types text/plain application/javascriptapplication/x-javascripttext/css application/xml
            text/javascriptapplication/x-httpd-php application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml;

            不要对图片文件进行 Gzip 压缩！对图片进行压缩不但会占用后台大量资源，压缩效果其实并不可观，可以说是“弊大于利”
            在gzip_types 把图片的相关项去掉\

        ...

        <4>.网络传输性能检测工具——Page Speed
            除了 network 版块，其实 chrome 还为我们准备好了一款监测网络传输性能的插件——Page Speed
            chrome 菜单 → 更多工具 → 拓展程序 → chrome 网上应用商店 → 搜索 pagespeed 后安转即可。
            只需要打开待测试的网页，然后点击 Page Speed 里的 Start analyzing 按钮，它就会自动帮我们测试网络传输性能了
            最人性化的地方，便是它会对测试网站的性能瓶颈提出完整的建议，我们可以根据它的提示进行优化工作。


    2.页面渲染性能优化：
     2.1：浏览器渲染过程（Webkit）
        参照图：浏览器的渲染过程.jpg

        注意：渲染方面 减少 重排 和 重绘 因为他们会影响浏览器性能。

        浏览器内部的渲染引擎、解释器等组件的关系： 见webkit内部渲染.jpg
            Chrome当前版本的貌似是Gecko（之前有Webkit、Blink）这里指的就是渲染引擎。
            渲染引擎包括：
                1.HTML 解释器：渲染时用于构造DOM树
                2.CSS 解释器：渲染时用于合成CSS规则
                3.JS 解释器：由于JS越来越复杂，现在被独立出来的，如V8引擎（Node.js在用）

     2.2：DOM 渲染层与 GPU 硬件加速
        一个页面是有许多许多层级组成的，他们就像千层面那样（div嵌套）。页面是由多个 DOM 元素渲染层（Layers）组成的，实际上一个页面
        在构建完 render tree 之后，是经历了这样的流程：
            1.浏览器会先获取 DOM 树并依据样式将其分割成多个独立的渲染层 （找到一块块的html嵌套）
            2.CPU 将每个层绘制进绘图中
            3.将位图作为纹理上传至 GPU（显卡）绘制
            4.GPU 将所有的渲染层缓存（如果下次上传的渲染层没有发生变化，GPU 就不需要对其进行重绘）并复合多个渲染层最终形成我们的图像

        布局是由 CPU 处理的，而绘制则是由 GPU 完成的。

        优化：
            GPU 会对我们的渲染层作缓存对吧，那么试想一下，如果我们把那些一直发生大量重排重绘的元素提取出来，单独触发一个渲染层，那样
            这个元素不就不会 "连累" 其他元素一块重绘了对吧。

        <1>.如何找到大量重排重绘的元素？如何单独触发一个渲染层？
            chrome 开发者工具菜单→ more tools → rendering（开启渲染性能监测工具）、Layers（开启渲染层功能模块）

            Rendering 版块：
                Paint flashing：勾选之后会对页面中发生重绘的元素高亮显示
                Layer borders：和我们的 Layer 版块功能类似，它会用高亮边界突出我们页面中的各个渲染层
                FPS meter：就是开启小黑窗，用于观察 GPU 占用率，清楚地知道页面是否发生了大量的重绘。

            Layers 版块：
                 DOM 渲染层的工具，左侧的列表里将会列出页面里存在哪些渲染层，还有这些渲染层的详细信息。

        <2>.什么情况下会触发渲染层？
            video 元素、WebGL、Canvas、CSS3 3D、CSS 滤镜、z-index 大于某个相邻节点的元素都会触发新的 Layer。
            其实我们最常用的方法，就是给某个元素加上下面的样式：
                transform: translateZ(0);
                backface-visibility: hidden;

            这样就可以触发渲染层啦 (^__^) 。

        <3>.啥是GPU加速？
            我们把容易触发重排重绘的元素单独触发渲染层，让它与那些 "静态" 元素隔离，让 GPU 分担更多的渲染工作，我们通常把这样的措施
            称为硬件加速，或者是 GPU 加速。现在完全清楚它的原理了吧。


     2.3重排和重绘
        1.重排（reflow）：渲染层内的元素布局发生修改，都会导致页面重新排列，比如窗口的尺寸发生变化、删除或添加 DOM 元素，修改了影响
        元素盒子大小的 CSS 属性（诸如：width、height、padding）。

        2.重绘（repaint）：绘制，即渲染上色，所有对元素的视觉表现属性的修改，都会引发重绘。

        chrome devtools 中的 performance 版块来测量页面重排重绘所占据的时间：
            蓝色部分：HTML 解析和网络通信占用的时间
            黄色部分：JavaScript 语句执行所占用时间
            紫色部分：重排占用时间
            绿色部分：重绘占用时间

        不论是重排还是重绘，都会阻塞浏览器。要提高网页性能，就要降低重排和重绘的频率和成本，近可能少地触发重新渲染。

        重排是由 CPU 处理的，而重绘是由 GPU 处理的，CPU 的处理效率远不及 GPU，并且重排一定会引发重绘，而重绘不一定会引发重排。所以
        在性能优化工作中，我们更应当着重减少重排的发生。https://csstriggers.com/  查看CSS 属性在不同的渲染引擎中是否会触发重排或重绘：

     2.4 优化策略
        （一）CSS 属性读写分离：浏览器没次对元素样式进行读操作时，都必须进行一次重新渲染（重排 + 重绘），所以我们在使用 JS 对元素
            样式进行读写操作时，最好将两者分离开，先读后写，避免出现两者交叉使用的情况。最最最客观的解决方案，就是不用 JS 去操作元素
            样式，这也是我最推荐的。

        （二）通过切换 class 或者 style.csstext 属性去批量操作元素样式

        （三）DOM 元素离线更新：当对 DOM 进行相关操作时，例、appendChild 等都可以使用 Document Fragment 对象进行离线操作，带元素
            "组装" 完成后再一次插入页面，或者使用 display:none 对元素隐藏，在元素 "消失" 后进行相关操作。

        （四）将没用的元素设为不可见：visibility: hidden，这样可以减小重绘的压力，必要的时候再将元素显示。

        （五）压缩 DOM 的深度，一个渲染层内不要有过深的子元素，少用 DOM 完成页面样式，多使用伪元素或者 box-shadow 取代。

        （六）图片在渲染前指定大小：因为 img 元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在
            渲染前就指定其大小，或者让其脱离文档流。

        （七）对页面中可能发生大量重排重绘的元素单独触发渲染层，使用 GPU 分担 CPU 压力。（这项策略需要慎用，得着重考量以牺牲 GPU
            占用率能否换来可期的性能优化，毕竟页面中存在太多的渲染层对与 GPU 而言也是一种不必要的压力，通常情况下，我们会对动画元素
            采取硬件加速。做隔离的单独渲染）

    3. JS 阻塞性能：
        在编程的过程中，如果我们使用了闭包后未将相关资源加以释放，或者引用了外链后未将其置空（比如给某 DOM 元素绑定了事件回调，后来
        却 remove 了该元素），都会造成内存泄漏的情况发生，进而大量占用用户的 CPU，造成卡顿或死机。

        1.在函数外调用闭包的影响：
            增加内存占用，正常的情况下：
                函数调用结束之后函数的执行环境离开环境栈 -> 定义的变量废弃 -> 活动变量（变量对象）销毁 -> 内存释放。

            但因为闭包的作用域链包含了外部函数的变量对象，外部函数的变量有可能再被引用，垃圾收集机制不会将外部函数的变量废弃，在内存
            保留的外部函数的变量对象。这样就加大了对内存的占用。
            var a;
            var bar = () => {
                let n = 100
                add = () => {   //函数内部方法引用了外部变量
                    n = n+1
                }
                return () =>{ return n }    //返回匿名函数
            }
            在调用bar()后，n会一直存在内存中，因为只要bar赋值给了其他变量，匿名函数就会一直存在内存当中，匿名函数又存在于bar，因此
            bar不会被垃圾机制回收，此时内存泄漏


        注意：
            没修炼到一定水平，千万别在服务端使用闭包！！一个是真没啥用，我们会有更多优良的解决办法。二是真的很容易内存泄漏，造成的
            后果是你无法预期的


    4.【拓展】负载均衡：
        如果是你自己搭建的个人网站，或者中小型网站，其实并不需要考虑多大的并发量，但是如果你搭建的是大型网站，负载均衡便是开发过程
        不可或缺的步骤。

      4.1 Node.js 处理 IO 密集型请求：
        现在的开发流程都注重前后端分离，也就是软件工程中常提到的“高内聚低耦合”的思想，你也可以用模块化的思想去理解，前后解耦就相当
        与把一个项目分成了前端和后端两个大模块，中间通过接口联系起来，分别进行开发。

        好处？
        - "异步编程"：敏捷开发。传统开发前端要等后端封装好接口。分离之后就可以两端同时开发。

        node的事件驱动：
            node 的核心是事件驱动，通过 loop 去异步处理用户请求，相比于传统的后端服务，它们都是将用户的每个请求分配异步队列进行处理。
            也就是只用一个线程来处理所有请求，事件驱动编程。

      4.2优劣，及实现"多进程"
        优势：
            就是在高并发 IO 时，不会造成堵塞，对于直播类网站，这点是至关重要的，我们有成功的先例——快手，快手强大的 IO 高并发究其本质
            一定能追溯到 node。
            现在的企业级网站，都会搭建一层 node 作为中间层。大概的网站框架如图：网站框架.jpg。SOAP可以使用微服务。

        劣势及解决方案：
            说 node 不行的都是指着 node 是单线程这一个软肋开撕。
            解决方案：
                pm2！http://pm2.keymetrics.io/
                一款node.js 进程管理器，具体的功能就是在你的计算机里的每一个内核都启动一个 node.js（多核启动多个）。
                并且它能够自动控制负载均衡！自动将用户的请求分发至压力小的服务进程上处理。简直就是神器

            知道我们在上线的时候需要用到它就行了，安装的方法也很简单，直接用 npm 下到全局就可以了
                $ npm i pm2 -g          使用方法还有相关特性可以参照官网。

      4.3 nginx 搭建反向代理：（图：正反向代理.png）
        要知道反向代理之前，首先要知道什么是正向代理。
        - 正向代理：
            类似一个跳板机，理解为搭建的ss中间的服务器。你用的是客户机 -> 通过配置代理服务器地址 -> 访问代理服务器
            代理服务器帮你请求网络资源 -> 接收响应的资源 -> 传给你的客户机

            用途：
                1.访问原来无法访问的资源，如google
                2.可以做缓存，加速访问资源
                3.对客户端访问授权，上网进行认证
                4.代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息

            正向代理是和客户端一起的，方便客户端访问资源。

        -反向代理：
            客户端是无感知代理的存在的，反向代理对外都是透明的，访问者者并不知道自己访问的是一个代理。客户端不需要任何配置就可以访问。
            接受internet上的连接请求（客户请求） -> 将请求转发给内部网络上的服务器 -> 从服务器上得到的结果 ->
            返回给internet上请求连接的客户端。此时代理服务器对外就表现为一个服务器。

            比如外网ip：106.72.78.90     内网ip：10.10.20.200 它对外利用的是外网ip，客户访问的都是外网。对内则把请求转到内网的服务器。

            用途：
                1.保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击。
                    大型网站，通常将反向代理作为公网访问地址，Web服务器是内网。
                2.负载均衡，通过反向代理服务器来优化网站的负载

            反向代理是和服务端一起的，方便预防攻击和缓解服务端压力。

        它的作用便是能够将用户的请求分配到压力较小的服务器上，其机制是轮询。

        反向代理起到的作用同 pm2 一样也是实现负载均衡，你现在应该也明白了两者之间的差异，反向代理是对服务器实现负载均衡，而 pm2 是
        对进程实现负载均衡。

        如何优化？
            改配置文件>_<
            http {
                upstream video {
                    ip_hash;
                    server localhost:3000;
                }
                server {
                    listen: 8080;
                    location / {
                        proxy_pass: http://video
                    }
                }
            }
        在 nginx 中，模块被分为三大类：handler、filter 和 upstream。而其中的 upstream 模块，负责完成完成网络数据的接收、处理和转发，
        也是我们需要在反向代理中用到的模块。

            4.3.1 upstream 配置信息：
                upstream ：紧跟的标识符是我们自定义的项目名称，通过一对花括号在其中增添我们的配置信息。
                ip_hash ：控制用户再次访问时是否连接到前一次连接的服务器。
                server ：我们真实服务器的地址，这里的内容肯定是需要我们去填写的，不然运维怎么知道你把项目放在那个服务器上了，也不
                    知道你封装了一层 node 而得去监听 3000 端口。

            4.3.2 server 配置信息：
                server 是 nginx 的基本配置，我们需要通过 server 将我们定义的 upstream 应用到服务器上。
                listen ：服务器监听的端口。
                location ：和我们之前在 node 层说到的路由是起同样的功能，这里是把用户的请求分配到对应的 upstream 上。

    5.扩展阅读：
        雅虎军规：https://www.cnblogs.com/xianyulaodi/p/5755079.html
