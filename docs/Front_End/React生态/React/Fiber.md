---
title: Fiber
order: 10
---

# 开始学他妈的

最近粗略的学习了一下 fiber，这是 react16 之后使用的新架构，正所谓好记性不如烂笔头，赶紧写下来装作自己会了。

## 为什么会出现 Fiber

至于为什么会出现 Fiber，那就首先从 react 的理念开始说起。

### React 的理念

React 的理念是什么呢？直接从[官网](https://zh-hans.reactjs.org/docs/thinking-in-react.html)搬过来的概念是这样子说的：

> 我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。
> 提取关键字：**快速响应**。

### 制约快速响应的因素

既然 react 的核心理念是快速响应，那么正常开发中一般会有哪些制约快速响应的因素呢。从个人角度出发的认知大概有两种：

- 因为 js 引擎和 ui 渲染引擎互斥原因，所以在进行 js 大量数据或者高度复杂计算的时候会出现页面 ui 渲染的卡顿
- 请求接口因为数据需要请求一段时间才能返回所导致的页面操作空档期（就是需要获取到数据之后才能进行下一步）

React 为了解决这些痛点，于是推出来了 Fiber 架构来解决这个问题。

## 如何解决计算时渲染卡顿

假如我们在页面里面写了这么一个组件：

```js
function Demo() {
  return new Array(5000).map((_, i) => {
    <div>{i}</div>;
  });
}
```

按照主流浏览器刷新率 60 帧计算，一帧就是 16.7ms。所以浏览器需要在 16.7ms 中完成以下三件事：

> js 计算 --> 样式计算 --> 样式布局
> 但是因为 **js 线程和 GUI 线程互斥**，js 计算的时候不能进行浏览器布局渲染，所以当 js 计算时间超出 16.7ms 的时候，浏览器就不能在这一帧里面进行样式布局和绘制了。

以上面的 Demo 为例，在 Demo 中由于绘制了 5000 个 dom，所用时间大幅度超过了 16.7ms，页面就会掉帧，那么在这些 dom 渲染的时候用户是会有感知的卡顿，所以 React 就给出了解决办法：

**在浏览器的每一帧时间中，预留一些时间给 js 线程，`React`利用这部分时间更新组件**（React 预留的时间是 5ms）。

当预留的时间不够的时候，React 会将线程控制权还给浏览器，使其有时间去渲染 UI。

> 这种方式将任务分成多个小任务，每次只执行一个小任务，这个小任务就称为**时间切片**
> 当我们将整个长任务拆分到每一帧去执行一个小任务的时候，js 线程大概只占用 5ms，浏览器就利用剩余时间去执行样式布局和样式绘制，减少了掉帧的可能性。

而实现时间切片的关键就是：将**同步的更新**变成**可中断的异步更新**。
