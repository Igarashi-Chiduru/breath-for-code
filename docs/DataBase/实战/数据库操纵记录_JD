零、对于数据库是否应设外键的讨论：
    主键和索引是不可少的，不仅可以优化数据检索速度，开发人员还省不其它的工作,

    优点：
        0.外键可以由数据库自身保证数据的一致性、完整性，因为程序很难100％保证数据的完整性。（不然当机、不同团队扩展难以处理）
        1.有主外键的数据库设计可以增加ER图的可读性，这点在数据库设计时非常重要
        2.外键在一定程度上说明的业务逻辑，会使设计周到具体全面。不用外键只能靠程序来维护逻辑

    缺点：
        0.不用外键时数据管理简单，操作方便，性能高,过分强调或者说使用主键／外键会平添开发难度，导致表过多。
        1.外键虽然保证完整性，但是对于主表删除这种操作，都级联扫描一遍所有的子表取删除，数据越大越慢，锁粒度也会大。
        2.用外键维护也麻烦，对于手动增删数据的维护，导入导出，其它高可用等，太麻烦。

    eg:在海量的数据库中想都不要去想外键，试想，一个程序每天要insert数百万条记录，当存在外键约束的时候，每次要去扫描此记录是否合格，
    一般还不 止一个字段有外键，这样扫描的数量是成级数的增长！

    结论：
        1.在大型系统中（性能要求不高，安全要求高），使用外键；在大型系统中（性能要求高，安全自己控制），不用外键；小系统随便，最好用外键。
        2.用外键要适当，不能过分追求
        3.不用外键而用程序控制数据一致性和完整性时，应该写一层来保证，然后个个应用通过这个层来访问数据库。


一、如何在线变更表结构：
    当数据量大、并发量高的场景下，如何在线数据库属性扩展？
    （1）alter table add column：
        不多解释了，大数据高并发情况下，一定不可行（锁表时间长）

    （2）通过增加表的方式扩展，通过外键join来查询：
        大数据高并发情况下，join性能较差，一定不可行

    （3）必须遵循“第x范式”的方案：
        一定不可行。互联网的主要矛盾之一是吞吐量（就是减少查询次数），为了保证吞吐量甚至可能牺牲一些事务性和一致性，通过
        反范式的方式来确保吞吐量的设计是很常见的。（虽然存在冗余数据，但减少查询次数，提高了性能）

    （4）让dba来搞？新表，迁移数据，一致性校验，rename？dba真苦逼

    可行方案：
    （1）提前预留一些reserved字段：
        但如果预留过多，会造成空间浪费，预留过少，不一定达得到扩展效果。


    以user(uid, name, passwd)举例，现在要扩展为 user(uid, name, passwd, age, sex)

    （2）version+ext：（版本号+通用列）
        以上面的用户表为例，假设只有uid和name上有查询需求，表可以设计为
        user(uid, name, version, ext)
        <1> uid和name有查询需求，必须设计为单独的列并建立索引

        <2> version是版本号字段，它对ext进行了版本解释（控制版本的字段）

        <3> 说白了就是个名为ext的字典，里面记录了除索引外的键值对，若下次要扩充，直接版本号+1 ext上直接扩字段即可
            uid    name    passwd    version    ext
             1      xx      xxxx        1    {"age":17,"sex":0} -- 之后就扩展这个字典

        缺点：可能太弱了，况且ext不支持索引，有冗余（建议key短一些）。有强需求索引可以使用MongoDB，它就是使用的json存储


    （3）key+value方案：（通过扩展行的方式来扩展属性）
        以上面的用户表为例，可以设计为
        user(uid, key, value)
        初期有name, passwd, nick三个属性，那么就是三对键值对
        uid    key    value
         1     name    xxx  。。。三对

        未来扩展了age和sex两个属性 那么uid对应的新键值对就
        uid    key    value
         3     name    xxx  。。。五对（添加了age、sex两组新键值对）

         缺点：key值有大量冗余（建议key短一些），本来一条记录很多属性，会变成多条记录，行数会增加很多。


    （4）新表+触发器：
        <1> 先创建一个扩充字段后的新表user_new(uid, name, passwd, age, sex)
        <2> 在原表user上创建三个触发器，对原表user进行的所有insert/delete/update操作，都会对新表user_new进行相同的操作
        <3> 分批将原表user中的数据insert到新表user_new，直至数据迁移完成
        <4> 删掉触发器，把原表移走（默认是drop掉）
        <5> 把新表user_new重命名（rename）成原表user   -- 之后扩充字段完成

        优点：整个过程不需要锁表，可以持续对外提供服务

        缺点：如果数据量太大，新表不一定装得下，何况触发器对数据库性能的影响比较高

        注意：
            1.变更过程中，最重要的是冲突的处理，一条原则，以触发器的新数据为准（这就要求被迁移的表必须有主键）
            2.变更过程中，写操作需要建立触发器，所以如果原表已经有很多触发器，方案就不行
                （互联网大数据高并发的在线业务，一般都禁止使用触发器）
            3.触发器的建立，会影响原表的性能，所以这个操作建议在流量低峰期进行


二、connection对象：
    connection对象用于数据库连接

    1.connection是一个很宝贵的资源，其封装了socket。当执行数据库操作就是通过connection实质就是通过socket将sql语句发送到数据库
        由数据库执行这些sql语句，这就是connection作用。

    2.因为创建一个connection是很耗时的操作，一般使用连接池提前建立好一些connection，并让这些connection跟数据库一直保持能通信
        这样就避免频繁的创建connection影响性能。

    3.connection是一种资源，不使用的时候最好将其归还到连接池，如果一直占用这个connection也是可以的但是浪费资源，有可能别的地方
        要使用到connection.再说了数据库的最大连接数也是有限的。

    4.一般连接池的返回的connection都是一个代理对象，其内部的close操作实际上只是将其归还给连接池，连接池会周期性的 或每次执行命令时
        检测connection对象是否能跟数据库通信，如果不能话 将其从数据库连接池中移除并会将其关闭，因为connection关联了socket这一
        系统的资源，关闭connection就相当于释放系统资源（句柄之类）。

    5.如果不使用连接池，直接close完就是相当关掉了socket，释放系统资源。


























