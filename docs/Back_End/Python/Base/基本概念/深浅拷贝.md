---
title: 深浅拷贝
order: 1
---

1.深浅拷贝
浅拷贝:
先说 a 变量的实现原理吧:
a = 1; b = a; b = 2 这里注意 a、b 是否有自己的地址 待论 --以论 大改 变量名还是理解为标签较好
这里 a 就当做是一个标签名为 a 1 在内存中当然有自己的地址但存放的值是 1 这里假设 1 的地址值为 0020
那么 a = 1 实际上就是在 a 这个标签里也就是变量 a 存放了 0020(1 的地址)
因此 print(a)时 a 里面存放的地址指针就指向了 0020 这块内存地址并取出了值 1

        b当然也是标签 这里设 2的地址为0024
        b = a 就是b标签也存放了a标签存放的内容 则是存放了 a标签存放的指向1的指针0020 因此 print(b)同理
        b = 2 又把b标签中存放的0020 改为了0024 因此存放了2 的地址 print(b)则打印2

        之前的误解:
            误解1:a b有自己的地址 但python中 a b 这样的变量名就相当于标签
            误解2:为b = a 则是在b中存放了a的地址 通过b->a->1来得到的1 然而显然python不是这样设计的
            python的设计哲学果然简洁合理  (就好似地址指针贴上了名为变量名的标签)
            因此赋值的过程就像-->标签改变指向的过程  参数传递的过程-->交换标签指向的过程

    下面进入正题:
        a=[[1,2],3,4]:  创建一个这样的列表 那么它的原理如下
            先说3,4 这里3和4 都有自己的内存地址 设1为0020 2:0024 以此类推 毋庸置疑3,4开辟了两个内存空间
            再看[1,2] 这是一个列表 对于这样一个列表来说 a标签存的则是这个列表的内存地址 (这样仔细一想也可以理解)
            毕竟[1,2]这个列表单拿出来也是一个元素 因此可见 list这种类型里面存的是元素的地址(对于整体而言)(包括元组、
            字典、的整体)
            设 [1,2] 地址值为0088 [0088,0028,0032]地址值为0400 因此a存放的便是0400的地址指针
            现在来看一下a列表存放的结构 如下:
                a存放了[0400]  [0400]里面又存放了[0088,0028,0032]
                a--->[0400]---->[0088,0028,0032]  然而下一个问题 0088 里面是什么

            0088里面又是一个列表 存放的则是[0020,0024] 1和2的地址指针

        b = a.copy(): 利用copy拷贝了一个a给b赋值(改标签) 这里利用copy()  b中存放地址的指针是和a[0400]一模一样的地址
        (同上的变量实现原理)     这种赋值不是b = a那样的赋值 改b中的元素是不会影响a的
            b标签的存放结构:
            设copy后拷贝了一个[0500]给b
            b存放了[0500]  [0500]里面又存放了[0088,0028,0032]
            b--->[0500]---->[0088,0028,0032] 此时b中的b[n]和a[n] 一样 b[0]当然也不例外  但b确和a不同
            那么当b[0][1]="3" 这样的操作实质上是改了0088里面的列表[0020,0024]-->[0020,0028]
            因此a里面的内容很不巧 随着b的改动而改动了

        以上就是解释为什么a会随着b的改动而变化了
        b = a[:] 等同于 b = a.copy() 本质上
        以上是浅拷贝 也就是只拷贝了地址(第一层的地址指针 )换了层皮但皮下本质相同 [0400]换成[0500]内不变
        因此列表中元素的地址还是指向的同一地方
        此时改[0500]存储的地址指针当然不会影响到[0400]
        但改[0088]也就是[0500][0400]共有的地址块[0400]则会受到影响

    之后讨论的是:
        b = a 这个和b = a.copy() 完全不同 因为这里就不是浅拷贝(不是换了层皮) 而是连皮都根本没换(披的是一层皮)
        b = a 就是b直接指向了a所属的(列表本身)地址(见下文)
            设a的标签中所存的[0088,0028,0032]地址设为0366
            那么b标签里存储的则是a标签的地址指针[0366]
        b---->[0366] 因此只要一改b 便是从b中指向了a标签的内容 就是改了a-[0366]-->[0088,0028,0032] [0366]里面的地址
        因此b = a 若改动实质上就是在改[0366]里的地址 然而a、b标签指向同一块[0366]这块区域 因此也被改动

        这里为什么看似和最先讨论的有差异呢?
            那是因为最先讨论的 a = 1; b = a 是b指向的不是a 而是1的地址 a[0020] b[0020] 因此当改动b时
            b = 2  此时b[0024] 但这没有影响到a 所以看似 改b不会影响a  (正是如此才要明白a b标签里面真正存的什么)
            那么该b的列表影响了a则是因此 改b的列表元素 确是在[0366]这个地址块的基础上改里面的地址指针
            因此影响了a  因此a、b是同生同死的共用同一肉体的两个人格(变量名不同其他完全一样 也就是换了个标签名内部内容一模一样)

        对比区别:
            设置c = ["a", "b", "c"] b = c
                此时b无论如何去改都不会影响a 而是去影响列表c 这就像是一开始讨论的变量实现原理了
                当b为列表时 列表有着自己的整块地址 又存储了各个分散的地址指针 因此只要没有重新指定b所存储的
                整个列表指针(存储各元素的地址块)那么就会影响a的值 当改为c后(b存储的地址块换了)才不会对a有影响

    总结:
        之所以列表会有这种情况就是忽略了地址所存储的本质 a标签 存的不是[0088,0028,0032] 而是[0088,0028,0032]的地址指针[0366]
        正是由于这块地址像神隐了一样容易忽视 才无法想通之前的解释

    二次验证:
        我理解的没错 当b=a.copy()时 a[1] 的地址 和b[1]的地址一模一样 就是说本质就是[0400]和[0500]的 区别
            见代码:
                a = [[1, 2], 3, 4]
                b = a.copy()
                print("a[1]：%d的内存地址是%d" % (a[1], id(a[1])))
                print("b[1]：%d的内存地址是%d" % (b[1], id(b[1])))


    以上便是浅拷贝和变量实现的对比  用途:很少 夫妻财产的共同实现?

    深拷贝: 通常情况下浅拷贝就足够了 因为浅拷贝只是换个皮 深拷贝则是实打实的全拷贝了一份 这就很占内存了

    import copy 导入copy模块
        .deepcopy(x) 便可以深拷贝 拷贝出一份涉及到动态数据类型就地址完全不同的的一份地址来给起赋值
        因此b[0]和a[0]的地址便完全不同 修改b中无论哪个元素,元素中的元素也都不会对a产生任何影响
