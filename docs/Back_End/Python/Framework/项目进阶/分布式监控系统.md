---
title: 分布式集群监控
order: 1
group:
  title: 项目进阶
  order: 25
---

# 分布式监控系统

## 监控需求及方式：

<6>
<7> 数据可视化： 目前有大量 UI 支持
<8> 如何实现单机 5000+： （意味着不能直接存数据库，数据量大会很慢）

<9> 采用何种方式通信：

- 主动通信：客户端可以主动向服务端要到数据
  - 好处：不用装客户端，使用所有的网络设备，snmp，配置简单

  - 坏处：服务器压力大，不适合大型网络环境，不能监控复杂的指标
- 被动通信：服务端被动接受到客户端的汇报数据
  - 好处：大型网络环境、监控复杂的指标、扩展能力强

  - 坏处：装客户端、网络设备不适用、维护起来相对复杂一点
- 混合模式：主流，既有主动又有被动

  - 1、客户端知道监控什么指标？ 客户端主动去问服务器我要监控什么

  - 2、客户端扫描本地所有服务，全部汇报给服务器 openfalcon 把机器上所有能检测到的都抓上[2014 年自动检测到（支持一千多项)]

<10> 如何实现监控服务器的水平扩展

## 架构设计：

#### 存储：

mysql：可以存每个服务器的配置（包括每台服务器要监控的那些资源项等）

redis-server: 并发量大，单机 10w+，存入缓存系统入 redis 中，可以非常的快，可以良好的支持水平扩展

#### 通信模式：

可采用方式 client -> server 形式

- 主动通信： Snmp，wget...

- 被动通信： Agent --- （客户端要能和服务端进行通信）

  - •Socket server –> Sockect client 费力不讨好，需要自己处理一切底层机制

- 用成熟的 C/S 架构体系：
  - rbmq：用队列，因为队列也有自己的服务端和客户端，用它自身的 socket

  - rpc：远程调用，如 twisted 自带的 rpc 通信机制的 客户端 Agent 和 服务端 Server 模式，可以支持异步等机制

  - redis：的订阅发布模式

  - http：直接用框架自带的 http，一样有自己的 socket，肯定也支持异步（简化架构、接口设计简单、容易水平扩展做分布式、socket 稳定成熟）

#### Http 特性：

1.短连接：客户端每次汇报数据后断开，不会给服务器制造压力

2.无状态：服务器端不保存客户端的状态，客户端的每次请求都是独一的，需要带自己的认证信息

3.安全认证：通信不被劫持

4.被动通信：标准的被动通信模式，服务端不会主动连客户端，除非 websocket

[tip]：客户端是不会存储配置信息的，尤其是每一台客户端的监控不一致。因此统一交给服务端来存储配置信息，每次客户端想服务端请求自身的配置
信息。（当前实现是存入 etcd 中，因此避免了服务端挂掉对集群所有客户端的影响）

[注]：若服务端改了一个客户端监控的配置，此时需要主动向客户端推并告知客户端，但是 http 是满足不了需求的，因此可以折中 - watch etcd： 由于本身采用 etcd 来存储各个机器上的告警配置，那么每次变化仅需要去监控 etcd 的告警设置即可，
最好能再弄一个回调机制，监控到有变化才去回调更新给客户端。否则可以开辟 另一个线程 专门负责监控，然后客户端每次轮询监控前，
读一下 线程的共享数据 threading.local() 中的 data_change 标志，若标志由 False 改为 True 则进行重新获取。 - 客户端定期的向服务端去取配置信息，如每 5 分钟向服务端同步配置信息

#### 业务流程（数据通信）

汇报数据：客户端向服务端汇报字典结构的数据，其中可以设置 status 字段来标志该监控是否该报警了 0 正常，其他出错了（如执行命令出错了等）

打时间戳：服务器端收到发过来的数据，第一件事就是打时间戳（客户端时间可能是不可信的）

存数据：此时不比对数据，直接存到 redis 里面

比对数据：同一时刻，可能有大量数据送入服务端，此时若去比对阈值，每个客户端的服务都要判断，因此服务端要无时无刻都去判断客户端有没有超
设定的阈值。正常来说应该有个独立的进程或线程或服务来专门干这件事，去不断的比对。

独立进程：Monitor Data Handler 若这个独立进程要比对数据，则还需要不断向 redis 请求数据进行比对（超过阈值的数据写入报警 queue）

需求差异：客户端立刻消费
